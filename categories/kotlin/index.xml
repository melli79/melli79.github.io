<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on Melchior&#39;s Homepage</title>
    <link>https://melli79.github.io/categories/kotlin/</link>
    <description>Recent content in Kotlin on Melchior&#39;s Homepage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 17 Jan 2023 19:00:51 +0100</lastBuildDate><atom:link href="https://melli79.github.io/categories/kotlin/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>21. Potenzen und Kleiner Satz des Fermat</title>
      <link>https://melli79.github.io/post/21fermatslittletheorem/</link>
      <pubDate>Tue, 17 Jan 2023 19:00:51 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/21fermatslittletheorem/</guid>
      <description>Nachdem wir letztes Mal Primzahlen gefunden haben und Multiplikation modulo $n$ betrieben haben, wollen wir heute Potenzen modulo $n$ betrachten.
1. Potenz-Tabelle Analog zur Multiplikationstabelle, wollen wir diesmal potenzieren modulo einer positiven ganzen Zahl $n$. Wenn wir $b^e\pmod{n}$ ausrechnen, haben wir mathematisch 2 Möglichkeiten: Wir können entweder mit großen ganzen Zahlen rechnen und zunächst $b^e$ ausrechnen und dann den Rest modulo $n$ bestimmen. Oder wir multiplizieren in einem fort, d.h. fangen bei $b^2\equiv b * b \pmod{n}$ an, bestimmen den Rest modulo $n$ und gehen dann weiter zu $b^3\equiv b^2 * b \pmod{n}$.</description>
    </item>
    
    <item>
      <title>20 Zahlenkongruenzen und Primzahlen</title>
      <link>https://melli79.github.io/post/20numbercongruences/</link>
      <pubDate>Sun, 15 Jan 2023 20:45:50 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/20numbercongruences/</guid>
      <description>Im Dritten Teil der Serie, Einführung in das Programmieren, wollen wir weitere mathematische Spiele betreiben. Heute wollen wir mit Zahlenkongruenzen rechnen.
1. Etwas Theorie Du erinnerst dich vielleicht noch an das erste Programm, in dem wir die Multiplikationstabelle (also das kleine 1x1) dargestellt haben. Diesmal wollen wir das aber etwas abändern. Statt dem ganzen Produkt geben wir nur den Rest bei Division durch die ganze Zahl $n$ aus. Das bedeutet folgendes: Wenn wir $3 * 5$ ausrechnen und $n=6$, dann dividieren wir das Zwischenergebnis $15$ durch $6$ und erhalten $2$ Rest $3$.</description>
    </item>
    
    <item>
      <title>16. Wirbel im Computer</title>
      <link>https://melli79.github.io/post/16curlsonthecomputer/</link>
      <pubDate>Sun, 04 Sep 2022 12:35:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/16curlsonthecomputer/</guid>
      <description>Nachdem wir letztens Fraktale gemalt haben, wollen wir heute Animationen produzieren.
Das Ziel Your browser does not support the video tag. 0. Programm aufsetzen So wie bei den meisten Desktop Grafik-Apps, starten wir mit einem Hauptprogramm, dass ein Fenster anlegt, in dem dann unsere Komponente dargestellt wird.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MyWindow(private val content :JComponent) :JFrame(&amp;#34;Curls on the Computer&amp;#34;), KeyListener { init { layout = BorderLayout() contentPane = content setSize(800, 600) defaultCloseOperation = EXIT_ON_CLOSE addKeyListener(this) .</description>
    </item>
    
    <item>
      <title>15 Iterierte Funktionssysteme</title>
      <link>https://melli79.github.io/post/15iteratedfunctionsystems/</link>
      <pubDate>Sun, 21 Aug 2022 12:35:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/15iteratedfunctionsystems/</guid>
      <description>Nachdem wir letzte Wochen das Mandelbrot und den Baum des Pythagoras gemalt haben, wollen wir heute weitere Fraktale produzieren.
Das Ziel 0. Programm aufsetzen Das kennst du schon: Ein neues Kotlin-Projekt anlegen und das Hauptprogramm ausfüllen, etwa so:
1 2 3 4 5 6 7 8 9 10 11 12 13 class MyWindow(content :JComponent) :JFrame(&amp;#34;Iteriertes Funktionensystem&amp;#34;) { init { layout = BorderLayout() contentPane = content defaultCloseOperation = EXIT_ON_CLOSE setSize(800, 600) } } fun main() { val window = MyWindow(IFS(System.</description>
    </item>
    
    <item>
      <title>14 Baum des Pythagoras</title>
      <link>https://melli79.github.io/post/14baumdespythagoras/</link>
      <pubDate>Fri, 19 Aug 2022 18:35:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/14baumdespythagoras/</guid>
      <description>Nachdem wir letzte Woche das Mandelbrot und Julia-Mengen gemalt haben, wollen wir heute weitere Fraktale produzieren.
Das Ziel 0. Programm aufsetzen Das kennst du schon: Ein neues Kotlin-Projekt anlegen und das Hauptprogramm ausfüllen, etwa so:
1 2 3 4 5 6 7 8 9 10 11 12 13 class MyWindow(content :JComponent) :JFrame(&amp;#34;Baum des Pythagoras&amp;#34;) { init { layout = BorderLayout() contentPane = content defaultCloseOperation = EXIT_ON_CLOSE setSize(800, 600) } } fun main() { val window = MyWindow(TreeOfPythagoras()) window.</description>
    </item>
    
    <item>
      <title>13 Mandelbrot (Apfelmännchen)</title>
      <link>https://melli79.github.io/post/13mandelbrot/</link>
      <pubDate>Sat, 25 Jun 2022 12:35:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/13mandelbrot/</guid>
      <description>Nachdem wir letzte Woche Korbmuster gemalt haben, wollen wir heute weitere mathematische Kunst produzieren.
Das Ziel 0. Programm Aufsetzen Das kennst du vielleicht schon: Du legst ein neues Kotlin/JVM-Projekt an und schreibst das Hauptprogramm etwa so:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MainWindow(contentPane :JComponent) :JFrame(&amp;#34;Mandelbrot&amp;#34;) { init { this.layout = BorderLayout() this.contentPane = contentPane this.setSize(500, 500) defaultCloseOperation = EXIT_ON_CLOSE } } fun main(args :Array&amp;lt;String&amp;gt;) { val window = MainWindow(Mandelbrot()) window.</description>
    </item>
    
    <item>
      <title>12 Moderne Kunst</title>
      <link>https://melli79.github.io/post/12modernart/</link>
      <pubDate>Mon, 18 Apr 2022 16:05:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/12modernart/</guid>
      <description>Nachdem wir letzte Woche Augen gemalt haben, wollen wir heute moderne Kunst produzieren.
Das Ziel 1. Projekt aufsetzen Das geht so ähnlich wie beim letzten Projekt: Unter Datei &amp;gt; Neu &amp;gt; Projekt &amp;hellip; ein Kotlin-Projekt mit Namen &amp;ldquo;Modern Art&amp;rdquo; aufsetzen mit dem gleichen JDK wie beim letzten Mal.
Dann im Hauptprogramm &amp;ldquo;Main.kt&amp;rdquo;:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MainWindow(contentPane :JComponent) :JFrame(&amp;#34;Modern Art&amp;#34;) { init { this.</description>
    </item>
    
    <item>
      <title>11 Augen malen</title>
      <link>https://melli79.github.io/post/11eyes/</link>
      <pubDate>Sun, 10 Apr 2022 12:31:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/11eyes/</guid>
      <description>Nachdem ihr eine Entwicklungsumgebung aufgesetzt habt, wollen wir heute etwas malen.
Das Ziel 1. Projekt aufsetzen So, wie in der Anleitung im Schritt 2B angegeben, erstellt ihr eine Datei &amp;gt; Neu &amp;gt; Projekt &amp;hellip; vom Typ Kotlin, Console Application. Ihr könnt dem Projekt einen ordentlichen Namen geben, z.B. Eyes (engl. für Augen), achtet darauf, dass das Build-System Gradle-Kotlin ist, das Projekt open JDK 11 (oder was ihr damals als Java-Umgebung installiert habt) verwendet.</description>
    </item>
    
    <item>
      <title>03C Frauen Gebären und sich Scheiden lassen</title>
      <link>https://melli79.github.io/post/03cwomengivebirth/</link>
      <pubDate>Thu, 23 Dec 2021 18:10:51 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/03cwomengivebirth/</guid>
      <description>4. Frauen Gebären Woher kommen die Kinder?
Das soll jetzt kein Vortrag über das Kinderkriegen werden, aber wenn unser Modell Menschen beschreibt, dann sollte es auch Kinder produzieren können.
Im Einfachsten Fall bekommt eine Frau ein Kind und ihr Ehepartner ist der Vater. Die Signatur sieht etwa so aus:
1 2 3 fun Person.giveBirth(givenName :String, birthday :PartialDate, gender :Gender) :Person { ... } Offenbar brauchen wir auch das Geschlecht und den Geburtstag des Kindes.</description>
    </item>
    
    <item>
      <title>03B Leute können Heiraten</title>
      <link>https://melli79.github.io/post/03bpeoplecanmarry/</link>
      <pubDate>Wed, 22 Dec 2021 21:39:52 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/03bpeoplecanmarry/</guid>
      <description>Heute wollen wir schauen, was Personen tun können.
3. Zwei Personen können heiraten. Wenn wir schon ein Modell von Menschen haben, dann sollten die auch wie Menschen leben können. Als erstes wollen sie heiraten können.
Was sind die Voraussetzungen zum Heiraten? Man braucht einen Mann, eine Frau (oder 2 Männer oder 2 Frauen), die müssen beide ledig sein und alt genug und dann werden sie Mann und Frau (oder Mann und Mann oder Frau und Frau).</description>
    </item>
    
    <item>
      <title>03 Daten und Leute</title>
      <link>https://melli79.github.io/post/03dataandpeople/</link>
      <pubDate>Wed, 22 Dec 2021 19:40:39 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/03dataandpeople/</guid>
      <description>Heute soll es darum gehen, wie man Leute im Computer darstellt.
1. Was ist uns an Leuten wichtig? Ein echter Mensch ist 2&amp;ndash;200 kg schwer, besteht aus Haut, Muskeln, Knochen, &amp;hellip;, trägt Kleidung, &amp;hellip; . Die werden wahrscheinlich nicht in den Computer passen.
Stattdessen überlegen wir uns, was wir von einem Menschen darstellen wollen, d.h. wir bilden uns ein Modell.
Also ein Mensch hat
einen festen Vornamen, einen Familiennamen, ein Geburtsdatum, ein Geschlecht, einen Vater, eine Mutter, vielleicht eine/n Ehepartner/in, vielleicht Kinder.</description>
    </item>
    
    <item>
      <title>02 If und Schlümpfe</title>
      <link>https://melli79.github.io/post/02ifandsmurfs/</link>
      <pubDate>Mon, 20 Dec 2021 20:30:46 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/02ifandsmurfs/</guid>
      <description>Heute wollen wir Schlümpfe zählen. Das geht so:
Wir fangen mit den normalen Zahlen bei 1 an: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, &amp;hellip;
Dann ersetzen wir jede 5. Zahl durch Schlümpf entsprechend ihrem Vielfache:
1 1, 2, 3, 4, Schlümpf, 6, 7, 8, 9, 2 Schlümpf, 11, 12, 13, 14, 3 Schlümpf, 16, ... die 25 ist Schlümpf-Schlümpf. 0. Zahlenreihe Vom ersten Post erinnerst du dich bestimmt noch an for-Schleifen, mit denen man durchzählen kann, etwa so:</description>
    </item>
    
    <item>
      <title>22 Statistik und Geschlecht</title>
      <link>https://melli79.github.io/post/22statistics/</link>
      <pubDate>Sun, 19 Dec 2021 20:25:47 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/22statistics/</guid>
      <description>Heute wollen wir uns fragen, wie der Computer am Namen erkennen kann, ob jemand Mann oder Frau ist.
1. Woran erkennt man, ob jemand weiblich ist? Natürlich ist der Vorname nicht die einzige Quelle, anhand derer man das entscheiden kann, z.B. kann man oft auch am Surf- oder Kaufverhalten herausfinden, ob jemand Mann (Junge) oder Frau (Mädchen) ist.
Auch ist es nicht immer ganz eindeutig, ob jemand Mann oder Frau ist, z.</description>
    </item>
    
    <item>
      <title>01 For-Schleifen</title>
      <link>https://melli79.github.io/post/01loops/</link>
      <pubDate>Sat, 18 Dec 2021 23:21:50 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/01loops/</guid>
      <description>Nachdem Ihr die Programmierumgebung aufgesetzt habt, fangen wir heute mit einem ersten kleinen Programm an: Das kleine 1x1.
Das Ziel Das Ziel soll etwa folgende Tabelle sein:
1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90 100 Was wollen wir haben: Zeilen 1.</description>
    </item>
    
  </channel>
</rss>
