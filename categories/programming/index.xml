<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Melchior&#39;s Homepage</title>
    <link>https://melli79.github.io/categories/programming/</link>
    <description>Recent content in Programming on Melchior&#39;s Homepage</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 05 Feb 2023 10:55:45 +0100</lastBuildDate><atom:link href="https://melli79.github.io/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>24. Störungssichere Übertragung</title>
      <link>https://melli79.github.io/post/24errorcorrection/</link>
      <pubDate>Sun, 05 Feb 2023 10:55:45 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/24errorcorrection/</guid>
      <description>Nachdem wir letztes Mal über fälschungssichere Übertragung und Kryptographie gesprochen haben, wollen wir heute über störungssichere Übertragung sprechen.
1. Bilder von den Voyager-Sonden Zunächst sollten wir klären, wo man das einsetzen kann. Also die Voyager-Sonden wurden vor 75 Jahren in Richtung Neptun und jenseits des Sonnensystems losgeschickt, um Erkundungen des Weltraums auch dort zu ermöglichen. Zum einen hatten die Sonden ein paar Aufzeichnungen von der Menschheit auf der Erde (in den 1970ern) mit und zum anderen sind Kameras und starke Sendeanlagen in den Sonden eingebaut.</description>
    </item>
    
    <item>
      <title>23. Verschlüsselung und Signierung</title>
      <link>https://melli79.github.io/post/23encryptionandsigning/</link>
      <pubDate>Sun, 29 Jan 2023 21:10:53 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/23encryptionandsigning/</guid>
      <description>Nachdem wir letztes Mal den RSA Algorithmus kennen gelernt haben, wollen wir diesmal etwas allgemeiner über Kryptographie sprechen.
Wer lieber ein (kurzes) Buch liest, dem sei [1] empfohlen.
[1] A. Beutelspacher: Kryptologie, Eine Einführung in die Wissenschaft vom Verschlüsseln, Verbergen und Verheimlichen, Taschenbuch, November 2014.
1. Wenn Alice Bob eine geheime Nachricht schicken will&amp;hellip; Zunächst einmal, worum geht es eigentlich bei Kryptographie (als Teilgebiet der Mathematik/Informatik). Wir haben 2 Subjekte, die geheime Informationen über einen öffentlichen Kanal austauschen wollen.</description>
    </item>
    
    <item>
      <title>22. ggT, phi und RSA</title>
      <link>https://melli79.github.io/post/22eulerfermat/</link>
      <pubDate>Wed, 18 Jan 2023 18:00:52 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/22eulerfermat/</guid>
      <description>Nachdem wir letztes Mal mit Primzahlen und dem kleinen Satz von Fermat verschlüsselt haben, wollen wir heute die Grundlagen des RSA Algorithmus kennen lernen.
1. Potenzen modulo $n$, noch einmal Erinnern wir uns noch einmal an die Potenzen der Reste modulo $n$. Beim letzten Mal hatten wir dazu folgende Tabellen produziert:
1 2 3 4 5 6 7 8 9 Potenzen modulo 7: 0 1 2 3 4 5 6 7 1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 2 4 1 2 4 1 2 1 3 2 6 4 5 1 3 1 4 2 1 4 2 1 4 1 5 4 6 2 3 1 5 1 6 1 6 1 6 1 6 sowie</description>
    </item>
    
    <item>
      <title>21. Potenzen und Kleiner Satz des Fermat</title>
      <link>https://melli79.github.io/post/21fermatslittletheorem/</link>
      <pubDate>Tue, 17 Jan 2023 19:00:51 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/21fermatslittletheorem/</guid>
      <description>Nachdem wir letztes Mal Primzahlen gefunden haben und Multiplikation modulo $n$ betrieben haben, wollen wir heute Potenzen modulo $n$ betrachten.
1. Potenz-Tabelle Analog zur Multiplikationstabelle, wollen wir diesmal potenzieren modulo einer positiven ganzen Zahl $n$. Wenn wir $b^e\pmod{n}$ ausrechnen, haben wir mathematisch 2 Möglichkeiten: Wir können entweder mit großen ganzen Zahlen rechnen und zunächst $b^e$ ausrechnen und dann den Rest modulo $n$ bestimmen. Oder wir multiplizieren in einem fort, d.h. fangen bei $b^2\equiv b * b \pmod{n}$ an, bestimmen den Rest modulo $n$ und gehen dann weiter zu $b^3\equiv b^2 * b \pmod{n}$.</description>
    </item>
    
    <item>
      <title>20 Zahlenkongruenzen und Primzahlen</title>
      <link>https://melli79.github.io/post/20numbercongruences/</link>
      <pubDate>Sun, 15 Jan 2023 20:45:50 +0100</pubDate>
      
      <guid>https://melli79.github.io/post/20numbercongruences/</guid>
      <description>Im Dritten Teil der Serie, Einführung in das Programmieren, wollen wir weitere mathematische Spiele betreiben. Heute wollen wir mit Zahlenkongruenzen rechnen.
1. Etwas Theorie Du erinnerst dich vielleicht noch an das erste Programm, in dem wir die Multiplikationstabelle (also das kleine 1x1) dargestellt haben. Diesmal wollen wir das aber etwas abändern. Statt dem ganzen Produkt geben wir nur den Rest bei Division durch die ganze Zahl $n$ aus. Das bedeutet folgendes: Wenn wir $3 * 5$ ausrechnen und $n=6$, dann dividieren wir das Zwischenergebnis $15$ durch $6$ und erhalten $2$ Rest $3$.</description>
    </item>
    
    <item>
      <title>16. Wirbel im Computer</title>
      <link>https://melli79.github.io/post/16curlsonthecomputer/</link>
      <pubDate>Sun, 04 Sep 2022 12:35:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/16curlsonthecomputer/</guid>
      <description>Nachdem wir letztens Fraktale gemalt haben, wollen wir heute Animationen produzieren.
Das Ziel Your browser does not support the video tag. 0. Programm aufsetzen So wie bei den meisten Desktop Grafik-Apps, starten wir mit einem Hauptprogramm, dass ein Fenster anlegt, in dem dann unsere Komponente dargestellt wird.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MyWindow(private val content :JComponent) :JFrame(&amp;#34;Curls on the Computer&amp;#34;), KeyListener { init { layout = BorderLayout() contentPane = content setSize(800, 600) defaultCloseOperation = EXIT_ON_CLOSE addKeyListener(this) .</description>
    </item>
    
    <item>
      <title>15 Iterierte Funktionssysteme</title>
      <link>https://melli79.github.io/post/15iteratedfunctionsystems/</link>
      <pubDate>Sun, 21 Aug 2022 12:35:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/15iteratedfunctionsystems/</guid>
      <description>Nachdem wir letzte Wochen das Mandelbrot und den Baum des Pythagoras gemalt haben, wollen wir heute weitere Fraktale produzieren.
Das Ziel 0. Programm aufsetzen Das kennst du schon: Ein neues Kotlin-Projekt anlegen und das Hauptprogramm ausfüllen, etwa so:
1 2 3 4 5 6 7 8 9 10 11 12 13 class MyWindow(content :JComponent) :JFrame(&amp;#34;Iteriertes Funktionensystem&amp;#34;) { init { layout = BorderLayout() contentPane = content defaultCloseOperation = EXIT_ON_CLOSE setSize(800, 600) } } fun main() { val window = MyWindow(IFS(System.</description>
    </item>
    
    <item>
      <title>14 Baum des Pythagoras</title>
      <link>https://melli79.github.io/post/14baumdespythagoras/</link>
      <pubDate>Fri, 19 Aug 2022 18:35:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/14baumdespythagoras/</guid>
      <description>Nachdem wir letzte Woche das Mandelbrot und Julia-Mengen gemalt haben, wollen wir heute weitere Fraktale produzieren.
Das Ziel 0. Programm aufsetzen Das kennst du schon: Ein neues Kotlin-Projekt anlegen und das Hauptprogramm ausfüllen, etwa so:
1 2 3 4 5 6 7 8 9 10 11 12 13 class MyWindow(content :JComponent) :JFrame(&amp;#34;Baum des Pythagoras&amp;#34;) { init { layout = BorderLayout() contentPane = content defaultCloseOperation = EXIT_ON_CLOSE setSize(800, 600) } } fun main() { val window = MyWindow(TreeOfPythagoras()) window.</description>
    </item>
    
    <item>
      <title>13 Mandelbrot (Apfelmännchen)</title>
      <link>https://melli79.github.io/post/13mandelbrot/</link>
      <pubDate>Sat, 25 Jun 2022 12:35:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/13mandelbrot/</guid>
      <description>Nachdem wir letzte Woche Korbmuster gemalt haben, wollen wir heute weitere mathematische Kunst produzieren.
Das Ziel 0. Programm Aufsetzen Das kennst du vielleicht schon: Du legst ein neues Kotlin/JVM-Projekt an und schreibst das Hauptprogramm etwa so:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MainWindow(contentPane :JComponent) :JFrame(&amp;#34;Mandelbrot&amp;#34;) { init { this.layout = BorderLayout() this.contentPane = contentPane this.setSize(500, 500) defaultCloseOperation = EXIT_ON_CLOSE } } fun main(args :Array&amp;lt;String&amp;gt;) { val window = MainWindow(Mandelbrot()) window.</description>
    </item>
    
    <item>
      <title>12 Moderne Kunst</title>
      <link>https://melli79.github.io/post/12modernart/</link>
      <pubDate>Mon, 18 Apr 2022 16:05:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/12modernart/</guid>
      <description>Nachdem wir letzte Woche Augen gemalt haben, wollen wir heute moderne Kunst produzieren.
Das Ziel 1. Projekt aufsetzen Das geht so ähnlich wie beim letzten Projekt: Unter Datei &amp;gt; Neu &amp;gt; Projekt &amp;hellip; ein Kotlin-Projekt mit Namen &amp;ldquo;Modern Art&amp;rdquo; aufsetzen mit dem gleichen JDK wie beim letzten Mal.
Dann im Hauptprogramm &amp;ldquo;Main.kt&amp;rdquo;:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MainWindow(contentPane :JComponent) :JFrame(&amp;#34;Modern Art&amp;#34;) { init { this.</description>
    </item>
    
    <item>
      <title>11 Augen malen</title>
      <link>https://melli79.github.io/post/11eyes/</link>
      <pubDate>Sun, 10 Apr 2022 12:31:50 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/11eyes/</guid>
      <description>Nachdem ihr eine Entwicklungsumgebung aufgesetzt habt, wollen wir heute etwas malen.
Das Ziel 1. Projekt aufsetzen So, wie in der Anleitung im Schritt 2B angegeben, erstellt ihr eine Datei &amp;gt; Neu &amp;gt; Projekt &amp;hellip; vom Typ Kotlin, Console Application. Ihr könnt dem Projekt einen ordentlichen Namen geben, z.B. Eyes (engl. für Augen), achtet darauf, dass das Build-System Gradle-Kotlin ist, das Projekt open JDK 11 (oder was ihr damals als Java-Umgebung installiert habt) verwendet.</description>
    </item>
    
    <item>
      <title>00 Kotlin IDE Aufsetzen</title>
      <link>https://melli79.github.io/post/00-setup-ide/</link>
      <pubDate>Sat, 09 Apr 2022 11:50:55 +0200</pubDate>
      
      <guid>https://melli79.github.io/post/00-setup-ide/</guid>
      <description>1. Schritt: IntelliJ für Windows 64 herunterladen und installieren Als Entwicklungsumgebung für Kotlin empfehle ich IntelliJ Idea Kommunity-Version. Diese kann man von der Website von JetBrains herunterladen, wichtig ist es, auf den schwarzen Knopf (Community Version) zu klicken.
2A. Schritt: Java 11 Development Kit installieren Das sollte aus der IntelliJ IDE heraus gehen: Datei &amp;gt; Projektstruktur &amp;gt; Projekt &amp;gt; SDK &amp;gt; Download JDK
Im Dialog: Version 11, Oracle Open JDK auswählen.</description>
    </item>
    
  </channel>
</rss>
